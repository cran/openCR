<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Outline</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\bm}[1]{\mbox{\boldmath \(#1\)}}</p>

<p>\vspace{12pt}</p>

<p>The R package <strong>openCR</strong> fits both non-spatial and spatial capture&ndash;recapture models to data from open animal populations, where there is turnover during sampling. The interface generally resembles that of <strong>secr</strong> (Efford 2019) upon which <strong>openCR</strong> depends for some functions. This document explains the purpose and general features of <strong>openCR</strong>. Help pages should be consulted for more detail on particular functions. Worked examples using published datasets are given in another vignette <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a>, and simulation-based examples are in a further vignette openCR-simulations.pdf[<sup>footnote1].</sup> The spatial model was described by Efford and Schofield (2020).</p>

<p>This is still something of a work in progress, so be careful to check results &#39;make sense&#39; and be aware of <a href="#limitations">limitations</a>.</p>

<p>[<sup>footnote1]:</sup> These supplementary vignettes are not included with the package. It is intended to distribute them on the website <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>. Otherwise contact the author.</p>

<h1>Outline</h1>

<h2>Model types</h2>

<p><strong>openCR</strong>  fits nonspatial open-population models of the Cormack-Jolly-Seber (CJS) and Jolly-Seber-Schwarz-Arnason (JSSA[<sup>footnote2]</sup> or &#39;POPAN&#39;) types. JSSA models are offered in both full and conditional likelihood forms, each with several parameterizations of recruitment, and incorporating Pollock&#39;s robust design. Pradel analyses are also provided.</p>

<p>[<sup>footnote2]:</sup> As far as I know, this abbreviation was first used by Pledger et al. (2010). Recognising the contributions of Crosbie and Manly, Schofield and Barker (2009) and Cowen et al. (2010) referred to it the Crosbie-Manly-Arnason-Schwarz (CMAS) model. Link and Barker (2010) used &#39;Crosbie-Manly-Schwarz-Arnason&#39; (CMSA) for the same model. CMSA has since been used by various authors, including Schofield and Barker (2016). JSSA is used in <strong>openCR</strong> because this highlights its evolution from the widely known Jolly-Seber model. POPAN refers to the software of Schwarz and Arnason (1996), recycled as the name of a data type in MARK.</p>

<p>Spatial versions of the CJS and JSSA model types are also provided[<sup>footnote2a].</sup> The spatial models allow for &#39;multi&#39;, &#39;proximity&#39; or &#39;count&#39; detectors as defined in <strong>secr</strong>. Several functions are implemented for the decline in hazard of detection with distance. Movement between primary sessions may be modelled (cf Ergon and Gardner 2014; Glennie et al. 2019), but particular care is needed, especially with respect to <a href="#kernels">kernel</a> truncation.</p>

<p>[<sup>footnote2a]:</sup> The utility of the spatial CJS model type (CJSsecr) is in doubt because the distribution of detected animals is not uniform at first detection, but rather biased towards the vicinity of the detectors.</p>

<h2>Data</h2>

<p>Data are assumed to be from a robust design. Secondary sampling sessions are nested within primary sessions and all turnover (births, deaths, immigration or emigration) is between primary sessions (Pollock 1982). There may be a single secondary session per primary session (this limits identifiability of some parameters).</p>

<h2>Model specification and fitting</h2>

<p>Models are specified using formula notation as in <strong>secr</strong>. Possible predictors include both pre-defined variables for learned responses, trend over time, etc., and user-provided covariates. Models are fitted by numerically maximizing the log likelihood. The likelihood is formed as a product over capture histories (Pledger at al. 2010) rather than from summary statistics. The fitted model is an object of class &#39;openCR&#39; for which generic methods are implemented (<code>print</code>, <code>predict</code>, <code>AIC</code>, <code>plot</code> etc.).</p>

<p>Variation in a parameter between primary sessions is modelled as e.g., <code>model = phi ~ session</code>[<sup>footnote3].</sup> Within-session variation in detection parameters may also be modelled (see field vole example in <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a>).</p>

<p>[<sup>footnote3]:</sup> This is equivalent of ~t in Lebreton et al. (1992) or ~time in RMark, and <strong>openCR</strong> recognises <code>~ t</code> as a synonym of <code>~ session</code>.</p>

<h2>Parameterization</h2>

<p>A selection of parameterizations is offered for recruitment in JSSA models. Models can also be parameterized in terms of the time-specific population size (non-spatial models) or density (spatial models), avoiding the super-population parameter.</p>

<p>Super-population size (or density in the case of secr models) may be computed as a derived parameter from &#39;CL&#39; models with the function derived(), which also computes time-specific population sizes and densities.</p>

<h2>Features and limitations</h2>

<p><strong>openCR</strong> has definite <a href="#limitations">limitations</a> that may or may not be addressed in future versions. Important differences between <strong>secr</strong> and <strong>openCR</strong> are noted <a href="#differences">here</a>. Online help is not guaranteed: users should attempt to solve their own problems, or seek help from other users via <a href="http://www.phidot.org/forum/">phidot</a> or <a href="https://groups.google.com/forum/#!forum/secrgroup">secrgroup</a>.</p>

<h1>Dipper example</h1>

<p>We start with a simple nonspatial example. Lebreton et al. (1992) demonstrated Cormack-Jolly-Seber methods with a dataset on European Dipper (<em>Cinclus cinclus</em>) collected by Marzolin (1988). The object <code>dipperCH</code> distributed with <strong>openCR</strong> provides these data in the <strong>secr</strong> &#39;capthist&#39; format. See the Examples section of its help page <code>?dipperCH</code> for code to input the data from other sources.</p>

<pre><code class="r">library(openCR)                   # also loads secr
options(digits = 4, width = 90)   # for more readable output
</code></pre>

<p>Dippers were captured annually over 1981&ndash;1987. </p>

<pre><code class="r">m.array(dipperCH, never.recap = T)   # compare Lebreton et al. 1992 Table 10
</code></pre>

<pre><code>##       R 1982 1983 1984 1985 1986 1987 NRecap
## 1981 22   11    2    0    0    0    0      9
## 1982 60        24    1    0    0    0     35
## 1983 78             34    2    0    0     42
## 1984 80                  45    1    2     32
## 1985 88                       51    0     37
## 1986 98                            52     46
## 1987 93                                   93
</code></pre>

<p>We can fit a Cormack-Jolly-Seber model directly with <code>openCR.fit</code> and display the estimates:</p>

<pre><code class="r">dipper.phi.t &lt;- openCR.fit(dipperCH, type = &#39;CJS&#39;, model = phi~t)
predict(dipper.phi.t)
</code></pre>

<pre><code>## $p
##      session estimate SE.estimate    lcl    ucl
## 1981       1       NA          NA     NA     NA
## 1982       2   0.9021     0.02906 0.8286 0.9461
## 1983       3   0.9021     0.02906 0.8286 0.9461
## 1984       4   0.9021     0.02906 0.8286 0.9461
## 1985       5   0.9021     0.02906 0.8286 0.9461
## 1986       6   0.9021     0.02906 0.8286 0.9461
## 1987       7   0.9021     0.02906 0.8286 0.9461
## 
## $phi
##      session estimate SE.estimate    lcl    ucl
## 1981       1   0.6258     0.11165 0.3965 0.8098
## 1982       2   0.4542     0.06662 0.3295 0.5849
## 1983       3   0.4784     0.05845 0.3669 0.5921
## 1984       4   0.6244     0.05703 0.5079 0.7281
## 1985       5   0.6079     0.05483 0.4970 0.7088
## 1986       6   0.5833     0.05721 0.4688 0.6895
## 1987       7       NA          NA     NA     NA
</code></pre>

<pre><code class="r">plot(dipper.phi.t, par = &#39;phi&#39;, ylim = c(0,1), pch = 16, col = &#39;red&#39;)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk dipperCJS"/></p>

<p>From this example you can see some of the virtues of <strong>openCR</strong></p>

<ul>
<li>accessible data summaries </li>
<li>compact model specification</li>
<li>direct plotting and tabulation of results.</li>
</ul>

<p>See <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a> for more extensive analyses of this dataset.</p>

<h1>A brief survey of open population capture&ndash;recapture models</h1>

<p>There is a large literature on open-population capture&ndash;recapture modelling. Almost all modern models derive from the Cormack-Jolly-Seber (CJS) or Jolly-Seber (JS) models (Seber 1982), with refinements by Crosbie and Manly (1985), Schwarz and Arnason (1996), Pradel (1996) and others. The MARK software (White and Burnham 1999) implemented many of these developments and remains the standard. This section describes differences among models as they relate to <strong>openCR</strong>.</p>

<h2>CJS vs JS</h2>

<p>The split between the CJS and JS model lineages is fundamental. CJS models do not model the first capture of each animal; they condition on that capture and model subsequent recapture probabilities \(p\) and apparent survival \(\phi\). CJS estimates of apparent survival are robust and useful (Lebreton et al. 1992), but CJS models stop short of estimating abundance, recruitment or population trend.</p>

<p>JS models model the first capture of each animal, and lead either directly or indirectly to estimates of abundance and recruitment. The modern development of JS methods rests heavily on Schwarz and Arnason (1996), so <strong>openCR</strong> follows Pledger et al. (2010) in using the label &#39;JSSA&#39;. JSSA models were the basis of the POPAN software, which led to the POPAN data type in MARK. JSSA models are the main focus of <strong>openCR</strong>. </p>

<h2>Parameterization of recruitment in JSSA models</h2>

<p>The JSSA model appears in several different forms whose unity is obscured by differing parameterizations of recruitment. The classic POPAN formulation uses entry probabilities: the members of a notional superpopulation enter the population with time-specific probability \(\beta_j\) (PENT in MARK), an idea from Crosbie and Manly (1985). Other parameterizations are</p>

<ul>
<li>number of new entrants at each time \(j\)</li>
<li>per capita fecundity (new entrants at time \(j\) scaled by 1/number in population at \(j-1\))</li>
<li>seniority (reverse-time survival Pradel 1996, Nichols 2016)</li>
<li>population growth rate \(\lambda\)</li>
<li>(relative) number in population at each time \(j\)</li>
</ul>

<p>Estimates of recruitment or implied recruitment from any one of these six parameterizations can be used to infer the others[<sup>footnote4].</sup> The choice of parameterization rests on which is more natural for the problem in hand (and allows the desired constraints to be applied) and on practicalities (some are more likely to give numerical problems than others). </p>

<p>[<sup>footnote4]:</sup> except for some mostly trivial differences relating to removals</p>

<p>Schwarz (2001) is illuminating (see also chapter on Jolly-Seber models by Schwarz and Arnason in the MARK book, Cooch and White 2017). Pradel (1996),  Williams, Nichols and Conroy (2002: p.518 et seq.), Pledger et al. (2003, 2010) and Link and Barker (2005) also comment on and compare JS parameterizations. See also the MARK help page on &#39;Recruitment Parameters in Jolly-Seber models&#39; (&#39;Recruitment Parameters&#39; in the help index).</p>

<h2>Conditional vs full likelihood JSSA</h2>

<p>For each JSSA recruitment parameterization there is a choice between models that include the total number of detected individuals  (\(u_\cdot\) or \(n\) in different notations), and models that condition on this number. Conditional-likelihood models do not directly estimate abundance; abundance is estimated as a derived parameter (Schwarz and Arnason 1996). Full-likelihood models include abundance as a parameter. The choice of formulation has virtually no effect on the parameter estimates[<sup>footnote5].</sup> The conditional likelihood form is somewhat faster and easier to fit (Schwarz and Arnason 1996), and it focuses on parameters that are estimated robustly (apparent survival, seniority, population growth rate).</p>

<p>The conditional models discussed by Pradel (1996), Link and Barker (2005), Schofield and Barker (2016) and others lack a distinguishing label to indicate their collective similarity. The label Pradel&ndash;Link&ndash;Barker PLB is suggested by Efford and Schofield (2020).</p>

<p>[<sup>footnote5]:</sup> this may not be true for spatial models with spatially varying density, but these models are not considered in <strong>openCR</strong>.</p>

<h2>Sufficient statistics vs capture histories</h2>

<p>Historically the CJS and JS likelihoods have been expressed in terms of &#39;sufficient statistics&#39; that are time-specific counts of animals in different categories, such as the number caught, the number marked etc. This approach is used in the <strong>openCR</strong> function <code>JS.direct</code> and with the Pradel model type in <code>openCR.fit</code>. The likelihood may also be computed as a product over terms, one for each observed capture history[<sup>footnote6].</sup> Modelling of individual capture histories, is slower, but it is extremely flexible, allowing direct inclusion of censoring, learned responses, individual covariates, secondary sessions and other extensions. This is the approach used in MARK and <code>openCR.fit</code>.</p>

<p>[<sup>footnote6]:</sup> strictly, the product over observed histories is only one component of the likelihood</p>

<h2>Robust design</h2>

<p>Most published formulations of CJS and JSSA models admit only one secondary session per primary session. Data collected according to a robust design with multiple secondary sessions must be collapsed to a single sample per primary session. However, it is simple to adapt the capture-history models for multiple secondary occasions, and this makes better use of the data. MARK offers many specific robust design models. A robust design is assumed in <strong>openCR</strong>; data with a single secondary session per primary session are merely a special case.</p>

<h2>Spatial vs nonspatial</h2>

<p>Models may be spatially explicit or not. Nonspatial models ignore the spatial distribution of animals. Spatial models use the spatially explicit capture&ndash;recapture paradigm of Efford (2004), Borchers and Efford (2008) and Royle et al. (2014). Open population spatial models using MCMC were published by Gardner et al. (2010), Chandler and Clark (2014), Ergon and Gardner (2014), Whittington and Sawaya (2015) and others. Glennie et al. (2019) proposed a frequentist hidden Markov formulation. The spatial models in <strong>openCR</strong> are described by Efford and Schofield (2020) and provide very similar estimates to those of Glennie et al. (2019).</p>

<p>There are three major motivations for open spatial models</p>

<ul>
<li>allowance for varying extent of sampling area</li>
<li>modelling of individual heterogeneity due to differential access to detectors</li>
<li>separation of emigration and mortality</li>
</ul>

<p><strong>openCR</strong> fits spatial analogues of CJS and JSSA models by maximizing the likelihood. The abundance parameter is density \(D\) (animals per hectare) rather than population size \(N\). </p>

<p>Recruitment in spatial models may be modelled using parameterizations to those described above for non-spatial models, replacing &#39;number&#39; by &#39;density&#39;. The locations at which animals recruit are not modelled.</p>

<h2>Home-range shifts between primary sessions</h2>

<p>By definition, the interval between primary sessions is long enough for turnover due to births and deaths. It is also possible that resident animals shift their home ranges (i.e. disperse). Spatial models may either ignore such movement (Gardner et al. 2010, Chandler and Clark 2014, Whittington and Sawaya 2015) or attempt to model it (Ergon and Gardner 2014). There are good arguments for modelling movement:</p>

<ul>
<li>Movement that is ignored inflates estimates of the within-session scale of detection \(\sigma\), with flow-on effects on demographic parameters.</li>
<li>If the distribution of dispersal distances can be inferred from the detection histories of residents then it is possible in principle to separate actual mortality from losses due emigration (Ergon and Gardner 2014). However, the robustness and data requirements of movement models have yet to be fully understood.</li>
</ul>

<h1>Data structure and input</h1>

<p>Data should be provided to <code>openCR.fit</code> as <strong>secr</strong> &#39;capthist&#39; objects. The occasions of a single-session dataset are treated as open-population temporal samples. For spatial analyses, the capthist object should use a point detector type (&#39;multi&#39;, &#39;proximity&#39; or &#39;count&#39;).</p>

<p><strong>openCR</strong> mostly uses the terminology of primary and secondary sessions (Pollock 1982) rather than &#39;session&#39; and &#39;occasions&#39; as in <strong>secr</strong>. Where &#39;session&#39; appears without qualifier it refers to a primary session composed of one or more secondary sessions.</p>

<p>The optional <code>intervals</code> attribute of the capthist object defines the structure. If intervals are not specified then they default to 1.0 and each occasion is treated as a primary session. If intervals are specified then some may be zero; occasions separated by &#39;zero&#39; intervals are treated as secondary sessions within the same primary session, as in MARK. </p>

<p>A multi-session capthist object will be converted automatically to a single-session object using function <code>secr::join</code>. An appropriate intervals attribute is constructed, using the intervals attribute of the multi-session object for the intervals between primary sessions (1.0 if not specified), and setting other intervals to zero.</p>

<p>To construct your own capthist objects &ndash;</p>

<ol>
<li>Consult <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>, or</li>
<li>Convert a dataframe in RMark input format using <code>secr::unRMarkInput</code>, or</li>
<li>Read a MARK .inp input file with <code>read.inp</code>.</li>
</ol>

<p>Examples of data input code also appear on the help pages for data objects <code>FebpossumCH</code>, <code>fieldvoleCH</code>, <code>microtusCH</code> and <code>dipperCH</code>.</p>

<h1>Model types</h1>

<p>The various models available in <strong>openCR</strong> are named to encode the distinctions made in the &#39;Brief survey&#39;. Names are formed by concatenating four components:</p>

<ol>
<li>&#39;CJS&#39; vs &#39;JSSA&#39;</li>
<li>Spatial (&#39;secr&#39;) vs non-spatial (default, blank)</li>
<li>JSSA recruitment parameterization (&#39;f&#39;,&#39;l&#39;,&#39;b&#39;,&#39;g&#39;,&#39;BN&#39;,&#39;BD&#39;,&#39;N&#39;,&#39;D&#39; - see following)</li>
<li>JSSA likelihood conditional (&#39;CL&#39;) vs full (default, blank)</li>
</ol>

<p>Thus &#39;JSSAsecrfCL&#39; is a spatial JSSA model parameterized in terms of per capita recruitment \(f\) and fitted by maximizing the conditional likelihood (a spatial version of Link and Barker (2005), minus parameter covariation). Any movement model is specified separately with the &#39;movementmodel&#39; argument of <code>openCR.fit</code>.</p>

<p>Parameters vary with the type of model, as listed below. Each of these primary parameters (&#39;real&#39; parameters in MARK) may also be modelled as a linear combination of predictors on a suitable link scale, allowing the inclusion of covariates and constraints. The coefficients of the parameter-specific linear combinations are called &#39;beta&#39; parameters in MARK; the likelihood is maximized with respect to the concatenated list of beta parameters.</p>

<h2>Non-spatial <strong>openCR</strong> models</h2>

<h3>Parameters and model types</h3>

<p>Table 1. Parameter definitions and default link functions (nonspatial models)</p>

<table><thead>
<tr>
<th align="left">Parameter</th>
<th align="left">Symbol</th>
<th align="left">Link</th>
<th align="left">Description</th>
</tr>
</thead><tbody>
<tr>
<td align="left">p</td>
<td align="left">\(p\)</td>
<td align="left">logit</td>
<td align="left">capture probability (recapture probability for CJS)</td>
</tr>
<tr>
<td align="left">phi*</td>
<td align="left">\(\phi\)</td>
<td align="left">logit</td>
<td align="left">apparent survival</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">\(b\)</td>
<td align="left">mlogit</td>
<td align="left">entry probability cf PENT in MARK</td>
</tr>
<tr>
<td align="left">f*</td>
<td align="left">\(f\)</td>
<td align="left">log</td>
<td align="left">per capita recruitment rate</td>
</tr>
<tr>
<td align="left">gamma*</td>
<td align="left">\(\gamma\)</td>
<td align="left">logit</td>
<td align="left">seniority (Pradel 1996)</td>
</tr>
<tr>
<td align="left">lambda*</td>
<td align="left">\(\lambda\)</td>
<td align="left">log</td>
<td align="left">population growth rate (finite rate of increase)</td>
</tr>
<tr>
<td align="left">superN</td>
<td align="left">\(N\)</td>
<td align="left">log</td>
<td align="left">superpopulation size</td>
</tr>
<tr>
<td align="left">BN</td>
<td align="left">\(B_N\)</td>
<td align="left">log</td>
<td align="left">number of entrants</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">\(N_j\)</td>
<td align="left">log</td>
<td align="left">time-specific population size</td>
</tr>
</tbody></table>

<p>* parameters marked with an asterisk are scaled by the interval between primary sessions. </p>

<p>Table 2. Parameters of nonspatial <strong>openCR</strong> models</p>

<table><thead>
<tr>
<th align="left">Type</th>
<th>p</th>
<th>phi</th>
<th>b</th>
<th>f</th>
<th>gamma</th>
<th>lambda</th>
<th>superN</th>
<th>BN</th>
<th>N</th>
</tr>
</thead><tbody>
<tr>
<td align="left">CJS</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAbCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAfCL</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAgCL</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAlCL</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAb</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAf</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAg</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAl</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAB</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td align="left">JSSAN</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
</tr>
</tbody></table>

<p>Models with type ending in CL are of the Pradel&ndash;Link&ndash;Barker type.</p>

<h3>Non-spatial models using sufficient statistics</h3>

<p><strong>openCR</strong> mostly fits models by modelling capture histories one-by-one. An alternative faster method is to evaluate the likelihood expressed in terms of sufficient statistics. Sufficient statistics vary among models, but they are typically counts such as provided by the function <code>JS.counts</code>. The &#39;sufficient statistics&#39; approach is not compatible with individual covariates. The non-spatial model types &#39;Pradel&#39; and &#39;Pradelg&#39; are implemented in <strong>openCR</strong> using sufficient statistics (Pradel 1996) and therefore fall outside the main framework (Table 2). They correspond to &#39;JSSAlCL&#39; and &#39;JSSAgCL&#39; respectively, and estimate the same parameters as those models. Estimates should coincide except when there are losses on capture. &#39;Pradel&#39; is parameterized in terms of population growth rate (lambda) and &#39;Pradelg&#39; is parameterized in terms of seniority (gamma). </p>

<p>Additionally, the function <code>JS.direct</code> computes classic Jolly&ndash;Seber estimates using the sufficient statistics.</p>

<h2>Spatial <strong>openCR</strong> models</h2>

<p>Table 3. Parameter definitions and default link functions (spatial models)</p>

<table><thead>
<tr>
<th align="left">Parameter</th>
<th align="left">Symbol</th>
<th align="left">Link</th>
<th align="left">Description</th>
</tr>
</thead><tbody>
<tr>
<td align="left">lambda0</td>
<td align="left">\(\lambda_0\)</td>
<td align="left">log</td>
<td align="left">detection function intercept</td>
</tr>
<tr>
<td align="left">sigma</td>
<td align="left">\(\sigma\)</td>
<td align="left">log</td>
<td align="left">detection function scale (m)</td>
</tr>
<tr>
<td align="left">z</td>
<td align="left">\(z\)</td>
<td align="left">log</td>
<td align="left">detection function shape parameter (HHR, HAN, HCG, HVP)</td>
</tr>
<tr>
<td align="left">phi*</td>
<td align="left">\(\phi\)</td>
<td align="left">logit</td>
<td align="left">apparent survival</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">\(b\)</td>
<td align="left">mlogit</td>
<td align="left">entry probability (beta)</td>
</tr>
<tr>
<td align="left">f*</td>
<td align="left">\(f\)</td>
<td align="left">log</td>
<td align="left">per capita recruitment rate</td>
</tr>
<tr>
<td align="left">gamma*</td>
<td align="left">\(\gamma\)</td>
<td align="left">logit</td>
<td align="left">seniority (Pradel 1996)</td>
</tr>
<tr>
<td align="left">lambda*</td>
<td align="left">\(\lambda\)</td>
<td align="left">log</td>
<td align="left">population growth rate (finite rate of increase)</td>
</tr>
<tr>
<td align="left">superD</td>
<td align="left">\(D\)</td>
<td align="left">log</td>
<td align="left">superpopulation density</td>
</tr>
<tr>
<td align="left">BD</td>
<td align="left">\(B_D\)</td>
<td align="left">log</td>
<td align="left">entrants per hectare</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">\(D_j\)</td>
<td align="left">log</td>
<td align="left">time-specific population density</td>
</tr>
</tbody></table>

<p>* parameters marked with an asterisk are scaled by the interval between primary sessions. </p>

<p>Table 4. Parameters of spatial <strong>openCR</strong> models</p>

<table><thead>
<tr>
<th align="left">Type</th>
<th>lambda0</th>
<th>sigma</th>
<th>z</th>
<th>phi</th>
<th>b</th>
<th>f</th>
<th>gamma</th>
<th>lambda</th>
<th>superD</th>
<th>BD</th>
<th>D</th>
</tr>
</thead><tbody>
<tr>
<td align="left">CJSsecr</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrbCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrfCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrgCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrlCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrb</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrf</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrg</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrl</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrB</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td align="left">JSSAsecrD</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td align="left">secrCL</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">secrD</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
</tbody></table>

<p>Spatial models with type ending in CL have features in common with the Pradel&ndash;Link&ndash;Barker models, hence the label &#39;spatial PLB&#39;.</p>

<h1>Model formulae</h1>

<p>Formulae define a linear model for each &#39;real&#39; parameter (p, phi, sigma etc.) on the link scale (logit, log etc.). Alternative link functions not shown in Tables 1 and 3 are &#39;loglog&#39; and &#39;sin&#39;, both as defined in MARK.</p>

<p>The default linear combination for each parameter is a constant, null model (~1, parameter constant over time, unaffected by individual differences etc.). To include other effects build formulae using either predefined (built-in) predictors listed here, or the names of covariates.</p>

<h2>Built-in predictors</h2>

<p>Table 5. Built-in predictors (&#39;sessions&#39; refers to primary sessions)</p>

<table><thead>
<tr>
<th align="left">Predictor</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td align="left">session</td>
<td>all except &#39;superN&#39;, &#39;superD&#39;</td>
<td>Factor, one level per primary session</td>
</tr>
<tr>
<td align="left">t</td>
<td>all except &#39;superN&#39;, &#39;superD&#39;</td>
<td>synonym of &#39;session&#39;</td>
</tr>
<tr>
<td align="left">Session</td>
<td>all except &#39;superN&#39;, &#39;superD&#39;</td>
<td>Continuous time</td>
</tr>
<tr>
<td align="left">b</td>
<td>p, phi, lambda0, sigma</td>
<td>learned response (persists across sessions)</td>
</tr>
<tr>
<td align="left">B</td>
<td>p, lambda0, sigma</td>
<td>detector-specific transient (Markovian) response across sessions</td>
</tr>
<tr>
<td align="left">bk</td>
<td>p, phi, lambda0, sigma</td>
<td>detector-specific learned response (persists across sessions)</td>
</tr>
<tr>
<td align="left">bsession</td>
<td>p, lambda0, sigma</td>
<td>learned response within sessions</td>
</tr>
<tr>
<td align="left">Bsession</td>
<td>p, lambda0, sigma</td>
<td>transient (Markovian) response within sessions</td>
</tr>
<tr>
<td align="left">bksession</td>
<td>p, lambda0, sigma</td>
<td>detector-specific learned response within sessions</td>
</tr>
<tr>
<td align="left">Bksession</td>
<td>p, lambda0, sigma</td>
<td>detector-specific transient (Markovian) response within sessions</td>
</tr>
<tr>
<td align="left">h2</td>
<td>all except abundance</td>
<td>2-class finite mixture</td>
</tr>
<tr>
<td align="left">h3</td>
<td>all except abundance</td>
<td>3-class finite mixture</td>
</tr>
<tr>
<td align="left">age</td>
<td>all except abundance</td>
<td>age factor</td>
</tr>
<tr>
<td align="left">Age</td>
<td>all except abundance</td>
<td>linear effect on age</td>
</tr>
<tr>
<td align="left">Age2</td>
<td>all except abundance</td>
<td>linear effect on age\(^2\)</td>
</tr>
</tbody></table>

<p>Differences among the various learned responses may be understood by examining their effect on the parameter index array (PIA). This table illustrates the PIA slice corresponding to an individual with the non-spatial detection history shown (4 primary sessions, each of 4 secondary sessions). The values &#39;1&#39; and &#39;2&#39; refer to different parameter combinations, most commonly to levels of lambda0.</p>

<table><thead>
<tr>
<th align="left">Detection history :</th>
<th>0100 0000 0000 0100</th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td align="left">~bsession</td>
<td>1122 1111 1111 1122</td>
<td>persistent within primary session</td>
</tr>
<tr>
<td align="left">~Bsession</td>
<td>1121 1111 1111 1121</td>
<td>transient within primary session</td>
</tr>
<tr>
<td align="left">~b</td>
<td>1122 2222 2222 2222</td>
<td>persistent</td>
</tr>
<tr>
<td align="left">~B</td>
<td>1122 2222 1111 1122</td>
<td>transient across primary sessions</td>
</tr>
</tbody></table>

<p>IMPORTANT NOTE: Learned response predictors (&#39;b&#39;, &#39;bsession&#39; etc.) were re-defined in <strong>openCR</strong> 1.3.0. Models fitted with earlier versions should be re-fitted.</p>

<h2>User-provided covariates</h2>

<p>The rules for covariates largely follow <strong>secr</strong> (<a href="https://www.otago.ac.nz/density/pdfs/secr-overview.pdf">secr-overview.pdf</a>). Covariates may be at the level of primary session, secondary session (detection parameters only), individual (CL models only), or detector (spatial models only). Further complexity may be modelled by providing custom design data cutting across these categories (see below).</p>

<p>Individual and detector covariates are named columns in the &#39;covariates&#39; attributes of the respective capthist and traps object. Covariate names should differ from the built-in predictors (Table 5).</p>

<p>Primary session covariates are provided to <code>openCR.fit</code> in the argument &#39;sessioncov&#39;, rather than associated with a data object. If &#39;sessioncov&#39; is a vector (length equal to number of primary sessions) rather than a dataframe then it may be referenced as &#39;scov&#39; in model formulae. </p>

<p>Covariates for detection parameters in secondary sessions are provided in the &#39;timecov&#39; argument; if &#39;timecov&#39; is a vector (length equal to total number of secondary sessions) rather than a dataframe then it may be referenced as &#39;tcov&#39; in model formulae. </p>

<h1>More on modelling</h1>

<h2>Closed populations</h2>

<p>The types &#39;secrD&#39; and &#39;secrCL&#39; cause <code>openCR.fit</code> to treat the data as if from a closed population (no mortality, no recruitment, no movement); the intervals attribute is ignored. <strong>openCR</strong> 1.4 fits simple closed models faster than <strong>secr</strong> 3.2. This surprising result is due to multithreading, improved coding, and avoidance of some modelling complexity.</p>

<pre><code class="r">msk &lt;- make.mask(traps(captdata), buffer = 100, type = &#39;trapbuffer&#39;)

secr &lt;- secr.fit(captdata, detectfn = &#39;HHN&#39;, mask = msk, trace = FALSE)
openCR &lt;- openCR.fit(captdata, detectfn = &#39;HHN&#39;, mask = msk, type = &#39;secrD&#39;)

# massage the predict.openCR results to the same format as predict.secr
pred_openCR &lt;- plyr::rbind.fill(predict(openCR))[c(2,1,3),-1]
rownames(pred_openCR) &lt;- secr$realnames

# compare estimates
predict(secr)[,-1]
</code></pre>

<pre><code>##         estimate SE.estimate    lcl     ucl
## D          5.485     0.64703  4.356  6.9058
## lambda0    0.307     0.03413  0.247  0.3815
## sigma     28.764     1.30055 26.326 31.4283
</code></pre>

<pre><code class="r">pred_openCR
</code></pre>

<pre><code>##         estimate SE.estimate    lcl     ucl
## D          5.485     0.64479  4.356  6.9059
## lambda0    0.307     0.03403  0.247  0.3815
## sigma     28.764     1.29989 26.326 31.4283
</code></pre>

<pre><code class="r"># compare timings in seconds
c(secr = secr$proctime, openCR = openCR$proctime)
</code></pre>

<pre><code>##   secr.elapsed openCR.elapsed 
##           3.44           3.23
</code></pre>

<p>The maximised log likelihoods differ because <strong>openCR</strong> does not include the multinomial constant. <strong>secr</strong> has function <code>logmultinom</code> that lets us add it back:</p>

<pre><code class="r"># compare maximised log likelihoods
c(secr.logLik = logLik(secr), openCR.logLik = logLik(openCR) + logmultinom(captdata))
</code></pre>

<pre><code>##   secr.logLik openCR.logLik 
##        -758.9        -758.9
</code></pre>

<h2>Finite mixtures</h2>

<p>Two- and three-class finite mixtures (h2, h3) allow for individual heterogeneity in detection and turnover parameters (Pledger et al. 2003, 2010). Using one of these predictors in a formula causes a further real parameter &#39;pmix&#39; to be added. pmix is the proportion in latent mixture class 2 for h2, and the proportions in classes 2 and 3 for h3 (the proportion in class 1 is obtained by subtracting from 1). The implementation in <strong>openCR</strong> assumes that class membership applies across all parameters. The posterior probabilities of class membership for all detected individuals are returned as the &#39;posterior&#39; component of the fitted model. </p>

<p>Finite mixture likelihoods are prone to multimodality. Misleading estimates result when the numerical maximization settles on a local maximum (see also [secr-finitemixtures.pdf].</p>

<h2>Age</h2>

<p>If age is modelled as a factor then it is useful to group older animals in a maximum age class (&#39;maximumage&#39;). Animals are assumed to be first caught at age zero unless &#39;initialage&#39; is specified. &#39;maximumage&#39; and &#39;initialage&#39; are optional components of the &#39;details&#39; argument of openCR.fit. &#39;initialage&#39; can name an individual covariate to avoid the assumption that all animals are the same age at first detection.</p>

<p>For a quadratic relationship with age, specify an additive model with both Age and Age2 terms (e.g., model = phi ~ Age + Age2).</p>

<h2>Sampling intervals</h2>

<p>We have seen the role of the intervals attribute in defining primary and secondary sessions. Between-session intervals need to be specified only if they vary, or if you would like rates (phi, gamma, lambda, f) to be reported in time units other than the (implicitly constant) sampling interval. Scaling from the standardised parameter \(\theta_j\) to the interval-specific value \(\theta^\prime_j\) uses \(\theta^\prime_j = \theta_j^{T_j}\) where \(\theta_j\) is one of \(\phi_j\) or \(\lambda_j\), and \(T_j\) is the duration of interval \(j\).</p>

<p>Scaling \(\gamma\) follows the same pattern except that the relevant duration for \(\gamma_j\) is \(T_{j-1}\). Scaling per capita recruitment \(f_j\) is more tricky. We use \(f^\prime_j = (\phi_j + f_j)^{T_j} - \phi_j^{T_j}\).</p>

<h2>Custom design data</h2>

<p>Occasionally there is a need for covariates that do not relate specifically to individuals, sessions or detectors, and are not included as canned predictors. For this you must construct your own dataframe of design data and pass it as the &#39;dframe&#39; argument of <code>openCR.fit</code>. Design data are used as input to the <code>model.matrix</code> function (the &#39;data&#39; argument); <code>model.matrix</code> generates the design matrix for each real parameter. Design data are usually constructed internally in <code>openCR.fit</code> from named covariates and other predictors that appear in model formulae; if &#39;dframe&#39; is provided then the internally constructed design data are added as extra columns, overwriting any custom columns of the same name. The same design dataframe is used for all parameters.</p>

<p>Constructing &#39;dframe&#39; is fiddly. The dataframe should have one row for each combination of unique capture history, secondary session, detector and latent class (mixture). For nonspatial models without finite mixtures this collapses to one row for each capture history and secondary session. The order of rows follows that of the elements in an array with dimensions (\(n\), \(S\), \(K\), \(X\)) for \(n\) unique capture histories, \(S\) secondary sessions, \(K\) detectors and \(X\) latent classes[<sup>footnote8].</sup> The <strong>secr</strong> function <code>insertdim</code> can help to expand data into the correct row order.</p>

<p>[<sup>footnote8]:</sup> This rectangular (or cuboidal) configuration includes cells that are redundant and unused for a particular model type (e.g., cells corresponding to sessions at or before first capture in CJS models). However, the full complement of rows is required in dframe.</p>

<p>A warning: by default <code>openCR.fit</code> replaces the input capthist with a more compact version using only unique capture histories (the number of each is kept in the individual covariate &#39;freq&#39;; see the function <code>squeeze</code>). Design data are in terms of the &#39;squeezed&#39; capture histories.</p>

<p>In this example we define a function to construct custom design data for a learned response.</p>

<pre><code class="r">makedf.b &lt;- function (ch, spatial = FALSE, nmix = 1, naive = FALSE) {
    ch &lt;- squeeze(ch)
    # Construct matrix of logical values TRUE iff caught before 
    detected &lt;- apply(abs(ch),1:2,sum)&gt;0
    detected &lt;- t(apply(detected, 1, cumsum)&gt;0)
    if (naive)
        b &lt;- rep(FALSE, prod(dim(ch)[1:2]))
    else
        b &lt;- t(apply(detected, 1, function(x) {x[which.max(x)] &lt;- FALSE; x}))
    # For a simple non-spatial case: data.frame(customb = as.vector(b))  
    # More generally:
    n &lt;- nrow(ch)
    S &lt;- ncol(ch)
    K &lt;- if (spatial) dim(ch)[3] else 1
    data.frame(customb = insertdim(b, 1:2, c(n,S,K,nmix)))  
}
</code></pre>

<p>Now compare the result with the canned predictor &#39;b&#39; for a persistent learned response.</p>

<pre><code class="r">ovenj &lt;- join(ovenCH)
fitb &lt;- openCR.fit(ovenj, model = p ~ b)
fitbc &lt;- openCR.fit(ovenj, model = p ~ customb, dframe = makedf.b(ovenj))
AIC(fitb, fitbc)
</code></pre>

<pre><code>##                 model npar rank logLik   AIC  AICc dAIC AICwt
## fitb        p~b phi~1    3    2 -254.6 515.2 515.6    0   0.5
## fitbc p~customb phi~1    3    2 -254.6 515.2 515.6    0   0.5
</code></pre>

<p>Our custom model gives exactly the same result as the canned predictor &#39;b&#39; when type = &#39;CJS&#39; because the precise secondary session of first capture is irrelevant for CJS models (recaptures are modelled only for subsequent primary sessions unless <code>details$CJSp1 == TRUE</code>).</p>

<p>Discrepancies can arise with non-CJS models because these account for animals never detected. The corresponding likelihood component uses a distinct design matrix for a &#39;naive&#39; animal. To customize non-CJS models a separate dframe should be provided that applies to naive animals:</p>

<pre><code class="r">fitb2 &lt;- openCR.fit(ovenj, model = p ~ b, type = &#39;JSSAfCL&#39;, start = fitb)
fitbc2 &lt;- openCR.fit(ovenj, model = p ~ customb,  type = &#39;JSSAfCL&#39;, 
                    dframe = makedf.b(ovenj), dframe0 = makedf.b(ovenj, naive = TRUE))
AIC(fitb2, fitbc2)
</code></pre>

<pre><code>##                      model npar rank logLik  AIC AICc  dAIC  AICwt
## fitbc2 p~customb phi~1 f~1    4    4 -661.2 1330 1331 0.000 0.5637
## fitb2        p~b phi~1 f~1    4    1 -661.5 1331 1332 0.512 0.4363
</code></pre>

<h2>Transience</h2>

<p>An ad hoc adjustment for transience may be programmed as follows (cf Pradel et al. 1997).</p>

<pre><code class="r">makedf.resident &lt;- function (ch, spatial = FALSE, nmix = 1) {
    ch &lt;- squeeze(ch)
    n &lt;- nrow(ch)
    S &lt;- ncol(ch)
    K &lt;- if (spatial) dim(ch)[3] else 1
    primary &lt;- primarysessions(intervals(ch))
    detected &lt;- apply(abs(ch),1:2,sum)&gt;0
    nprimary &lt;- apply(detected, 1, function(x) length(unique(primary[x])))
    data.frame(resident = insertdim(nprimary&gt;1, 1, c(n,S,K,nmix)))  
}
</code></pre>

<p>A simpler approach is to code an individual covariate that scores whether an individual was detected in more than one primary session. </p>

<pre><code class="r">addresidentcov &lt;- function (ch) {
    primary &lt;- primarysessions(intervals(ch))
    detected &lt;- apply(abs(ch), 1:2, sum)&gt;0
    nprimary &lt;- apply(detected, 1, function(x) length(unique(primary[x])))
    covariates(ch) &lt;- data.frame(residentcov =  nprimary&gt;1)
    ch
}
</code></pre>

<p>Results are identical:</p>

<pre><code class="r">ovenj &lt;- join(ovenCH)
ovenj &lt;- addresidentcov(ovenj)
fitnull &lt;- openCR.fit(ovenj, model = phi ~ 1)
fitcov  &lt;- openCR.fit(ovenj, model = phi ~ residentcov)
fitdf   &lt;- openCR.fit(ovenj, model = phi ~ resident, dframe = makedf.resident(ovenj))
fits &lt;- openCRlist(fitnull, fitcov, fitdf)
AIC(fits)
</code></pre>

<pre><code>##                       model npar rank logLik   AIC  AICc  dAIC AICwt
## fitcov  p~1 phi~residentcov    3    2 -225.8 457.6 458.0  0.00   0.5
## fitdf      p~1 phi~resident    3    2 -225.8 457.6 458.0  0.00   0.5
## fitnull           p~1 phi~1    2    2 -254.6 513.2 513.4 55.56   0.0
</code></pre>

<pre><code class="r">pred &lt;- predict(fits, newdata = data.frame(resident = TRUE, residentcov = TRUE))
do.call(rbind, lapply(pred, &#39;[[&#39;, &#39;phi&#39;))
</code></pre>

<pre><code>##         resident residentcov estimate SE.estimate    lcl    ucl
## fitnull     TRUE        TRUE   0.4630     0.05473 0.3590 0.5703
## fitcov      TRUE        TRUE   0.7387     0.06112 0.6031 0.8402
## fitdf       TRUE        TRUE   0.7387     0.06112 0.6031 0.8402
</code></pre>

<p>Hines et al. (2003) suggested extending the definition of residence to include animals captured at least \(d\) days apart within a primary session; either of the approaches here may be modified accordingly. Here is the code for two individual covariates:</p>

<pre><code class="r">addresidentcov2 &lt;- function (ch, d = 1) {
    primary &lt;- primarysessions(intervals(ch))
    secondary &lt;- secondarysessions(intervals(ch))
    detected &lt;- apply(abs(ch), 1:2, sum)&gt;0
    nprimary &lt;- apply(detected, 1, function(x) length(unique(primary[x])))
    dsecondary &lt;- apply(detected, 1, function(x) 
        max(by(secondary[x], primary[x], function(y) diff(range(y)))))
    covariates(ch) &lt;- data.frame(residentcov1 = nprimary&gt;1,
                                 residentcov2 = nprimary&gt;1 | dsecondary&gt;=d)
    ch
}
</code></pre>

<h2>Factor coding</h2>

<p>Factor predictors take a number of discrete values (levels). These are usually represented by columns of 0&#39;s and 1&#39;s in the design matrix, where the number of columns (and coefficients) relates to the number of levels. The default in R is to use &#39;treatment contrasts&#39;; one coefficient describes a reference class (level) and other coefficients represent the effect size (difference from the reference class on the link scale). By default the first level is used as the reference: for time effects (t, session) the first primary session is the reference level[<sup>footnote9].</sup></p>

<p>This may lead to trouble if the parameter is not identifiable in the reference class. One workaround is to specify a session covariate with differently ordered levels. Another is to switch from treatment contrasts to dummy variable coding in which each coefficient represents the magnitude of one real parameter on the link scale (useful in itself). Dummy variable coding is achieved by overriding the default contrasts and removing the intercept from the formula (-1). The following model fits yield the same estimates of &#39;real&#39; parameters and the same log-likelihood, but with different &#39;beta&#39; parameters:</p>

<pre><code class="r">fit0 &lt;- openCR.fit(ovenCH, model = p~t)
contr.none &lt;- function(n) contrasts(factor(1:n), contrasts = FALSE)
fitd &lt;- openCR.fit(ovenCH, model = p ~ -1+t, 
                   details = list(contrasts = list(t = contr.none)))
coef(fit0)
</code></pre>

<pre><code>##          beta SE.beta     lcl     ucl
## p    -1.54954  0.2459 -2.0316 -1.0675
## p.t3  0.32964  0.3280 -0.3133  0.9725
## p.t4 -1.42725  0.5259 -2.4581 -0.3964
## p.t5 -0.14372  0.4489 -1.0236  0.7361
## phi  -0.03141  0.2399 -0.5016  0.4388
</code></pre>

<pre><code class="r">coef(fitd)
</code></pre>

<pre><code>##          beta SE.beta     lcl     ucl
## p.t2 -1.54955  0.2459 -2.0316 -1.0675
## p.t3 -1.21990  0.2188 -1.6487 -0.7911
## p.t4 -2.97677  0.4663 -3.8907 -2.0628
## p.t5 -1.69324  0.3783 -2.4347 -0.9518
## phi  -0.03143  0.2399 -0.5016  0.4387
</code></pre>

<p>[<sup>footnote9]:</sup> This does not apply for times when a parameter can never be estimated &ndash; for example, <strong>openCR</strong> understands that seniority (gamma) is not estimated for the first session and uses the second session for the reference level. </p>

<h2>Mean of a parameter across levels of a factor</h2>

<p>Suppose you wish to estimate the average of a parameter across levels of a factor such as time (session). Cooch and White (2017 Section 6.15) advocate modifying the design matrix so that one beta parameter (coefficient) relates directly to the mean. This is achieved very simply in <code>openCR.fit</code>[<sup>footnote10]</sup> by setting the contrast function for the factor to <code>contr.sum</code> in the <code>details</code> argument[<sup>footnote11].</sup> With the resulting factor coding the first coefficient corresponds to the mean. Applying this to estimate the average time-specific survival rate for the dippers assuming constant recapture probability:</p>

<pre><code class="r">fit &lt;- openCR.fit(dipperCH, model = phi~t, details = list(contrasts = list(t = contr.sum)))
invlogit(coef(fit)[&#39;phi&#39;,c(&#39;beta&#39;,&#39;lcl&#39;,&#39;ucl&#39;)])
</code></pre>

<pre><code>##       beta   lcl    ucl
## phi 0.5633 0.505 0.6199
</code></pre>

<p>The mean is backtransformed from the link scale. This results in some bias owing to the nonlinearity of link functions other than the identity function. Cooch and White take the position that the bias is often ignorable. </p>

<p>[<sup>footnote10]:</sup> This also works in <code>secr.fit</code>.
[<sup>footnote11]:</sup> Helmert contrasts (<code>contr.helmert</code>) also yield the mean as the first coefficient, but the coding is more obscure.</p>

<h1>Movement models</h1>

<p>Potential movement of home ranges between primary sessions (= dispersal) is a critical part of open-population models. The argument <code>movementmodel</code> of <code>openCR.fit</code> allows the possibilities in Table 6. Two of these do not model movement at all. The default &#39;static&#39; is a null model in which each animal retains the same home range. The &#39;uncorrelated&#39; option models the locations of an animal independently in each primary session; information is sacrificed and no particular movement model is implied.</p>

<p>The remaining options (normal, exponential, t2D, uniform, and user-supplied function) fit a dispersal kernel (Nathan et al. 2012) to represent movement between primary sessions. This usually requires at least one more parameter to represent the spatial scale of dispersal. </p>

<p>IMPORTANT NOTE: Movement models were recoded in <strong>openCR</strong> 1.4.0 and results may differ from previous releases.</p>

<p><strong>Table 6</strong>. Models for movement between primary sessions.</p>

<table><thead>
<tr>
<th>Movement model</th>
<th>Parameter(s)</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code>static</code></td>
<td>(none)</td>
<td>Centres constant across primary sessions</td>
</tr>
<tr>
<td><code>uncorrelated</code></td>
<td>(none)</td>
<td>Centres unconstrained</td>
</tr>
<tr>
<td><code>normal</code></td>
<td><code>move.a</code></td>
<td>Gaussian (bivariate normal) kernel</td>
</tr>
<tr>
<td><code>exponential</code></td>
<td><code>move.a</code></td>
<td>Laplace (negative exponential) kernel</td>
</tr>
<tr>
<td><code>t2D</code></td>
<td><code>move.a</code>, <code>move.b</code></td>
<td>2-dimensional \(t\)-distribution kernel</td>
</tr>
<tr>
<td><code>uniform</code></td>
<td>(none)</td>
<td>Uniform within kernel radius</td>
</tr>
<tr>
<td>(user function)</td>
<td><code>move.a</code>, <code>move.b</code></td>
<td>User-supplied kernel function (<code>ncores = 1</code> only)</td>
</tr>
</tbody></table>

<h2>Movement kernels {#kernels}</h2>

<p>All movement kernels are radially symmetrical. Relative probability of movement is specified in terms of radial distance \(r\) from the point of origin (Table 7). </p>

<p>The extent of the kernel is controlled by details argument &#39;kernelradius&#39; that gives the radius in terms of mask cells. The default radius (10) results in a discretized kernel of 349 cells (square of 441 cells minus corners). Cell-specific values are normalised so that they sum to 1.0 across the kernel. Dispersal probability effectively falls to zero at the boundary of the kernel, so the kernel radius is a critical part of the model. The &#39;uniform&#39; kernel has no parameters but depends critically on the user-specified kernel radius.</p>

<p><strong>Table 7</strong>. Kernel probability density functions. From Nathan et al. (2012, Table 15.1) and Clark et al. (1999) with adjustment for parameterisation in <strong>openCR</strong>.</p>

<table><thead>
<tr>
<th>Kernel</th>
<th><code>move.a</code></th>
<th><code>move.b</code></th>
<th>pdf</th>
<th>Expected movement*</th>
<th>Proportion* \(r > R\)</th>
</tr>
</thead><tbody>
<tr>
<td>normal</td>
<td>\(\alpha_g\)</td>
<td></td>
<td>\(\frac{1}{2 \pi \alpha_g^2} \exp\left( \frac{-r^2}{2\alpha_g^2} \right)\)</td>
<td>\(\frac{\alpha_g \sqrt \pi}{\sqrt 2}\)</td>
<td>\(\exp \left( - \frac{R^2}{2 \alpha_g^2}\right)\)</td>
</tr>
<tr>
<td>exponential</td>
<td>\(\alpha_l\)</td>
<td></td>
<td>\(\frac{1}{2 \pi \alpha_l^2} \exp \left( \frac{-r}{\alpha_l} \right)\)</td>
<td>\(2 \alpha_l\)</td>
<td>\(\exp \left( - \frac{R}{\alpha_l}\right)\)</td>
</tr>
<tr>
<td>t2D</td>
<td>\(\alpha_t\)</td>
<td>\(\beta\)</td>
<td>\(\frac{\beta}{\pi \alpha_t^2} \left( 1 + \frac{r^2}{\alpha_t^2} \right)^{-(\beta+1)}\)</td>
<td>\(\alpha_t \frac{\sqrt \pi}{2} \frac{\Gamma \left( \beta-0.5 \right)}{\Gamma (\beta)}\), \(\beta > 0.5\)</td>
<td>\(\left(\frac{\alpha_t^2}{\alpha_t^2 + R^2} \right)^\beta\)</td>
</tr>
</tbody></table>

<p>* Continuous, untruncated, kernel. Expected values for the discretized and truncated kernel will be less (see <code>summary.kernel</code>).</p>

<p>\vspace{12pt}</p>

<p>The &#39;t2D&#39; kernel is the same as &#39;2Dt&#39; of Clark et al. (1999) and Nathan et al. (2012), renamed to avoid initial digit. The parameter \(\alpha_t\) (<code>move.a</code>) corresponds to \(a\) in Nathan et al. (2012) and \(\sqrt u\) in Clark et al. (1999); the parameter \(\beta\) (<code>move.b</code>) corresponds to \(b-1\) in Nathan et al. (2012) and \(p\) in Clark et al. (1999). Defining <code>move.b</code> as \(\beta \equiv b-1\) is handy because the default link for <code>move.b</code> (log) then ensures \(b>1\).</p>

<p>The t2D&#39; kernel approaches bivariate normal as \(\beta \to \infty\) and Cauchy as \(\beta \to 0\) (e.g., Clark et al. 1999).
Clark et al. (1999 p. 1485) found it hard to fit this kernel to seed dispersal data.</p>

<h2>User-defined kernel</h2>

<p>A kernel function may be specified by the user and passed in the argument <code>movementmodel</code>. The function should have argument \(r\), and optionally \(a\), or \(a\) and \(b\) (the last two correspond to <strong>openCR</strong> parameters <code>move.a</code> and <code>move.b</code>) It should return a vector of values one for each element of \(r\), although length&reg; = 1 when the likelihood is evaluated in C++ (<code>details$R = FALSE</code>, the default). The code should give a valid result when \(r = 0\). With the default link (&#39;log&#39; for both <code>move.a</code> and <code>move.b</code>) there is no risk of \(a \leq 0\) or \(b \leq 0\).</p>

<h2>Plotting and summary</h2>

<p>A kernel may be constructed with <code>make.kernel</code> and visualised with the <code>plot</code> method. Use the <code>summary</code> method to obtain a terse description. </p>

<pre><code class="r">par (mar=c(2,2,3,6), cex=0.9)
k &lt;- make.kernel (movementmodel = &#39;normal&#39;, spacing = 10, move.a = 40, clip = TRUE)
plot(k, contour = TRUE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk plotkernel"/></p>

<pre><code class="r">summary(k)
</code></pre>

<pre><code>## Kernel radius (cells)     :  10 
## Spacing (side of cell)    :  10  (m)
## Number of cells           :  349 
## Movement model            :  normal 
## Parameter(s)              :  move.a = 40 
## Proportion truncated      :  0.03189 
## Expected movement (trunc) :  47.91  (m)
## Expected movement (full)  :  50.13  (m)
</code></pre>

<p>Use the <strong>secr</strong> function <code>spotHeight(k)</code> to display cell values on the plot.</p>

<h2>Warnings</h2>

<ol>
<li><p>The &#39;uncorrelated&#39; option is not recommended. It discards information on the continuity of home ranges between primary sessions, and estimates may vary with the (often arbitrary) extent of the habitat mask.</p></li>
<li><p>Kernel-based movement models require extreme care. Definitive advice cannot yet be given on the safe use of these models. Long-distance movements will usually be poorly sampled and poorly modelled.</p></li>
<li><p>User-defined functions cannot be used with multithreaded C++, so they will be slow to fit; always set <code>ncores = 1</code>.</p></li>
</ol>

<h1>Derived parameters</h1>

<p>Various derived parameters may be computed from a fitted model. Specifically,</p>

<ol>
<li>Abundance at each primary session (population size for non-spatial models or density for spatial models) may be computed from any JSSA model, including those fitted by maximizing the conditional likelihood. By default, the estimator is Horvitz-Thompson-like at the level of the superpopulation (\(N\) or \(D\)). For non-spatial models \(\hat N = \sum_{i=1}^n \hat p_{i}^{-1}\) where \(\hat p_{i}\) is the estimated probability animal \(i\) is seen in at least one session. For spatial models \(\hat D = \sum_{i=1}^n \hat a_{i}^{-1}\), where \(\hat a_{i}\) is the estimated effective sampling area of animal \(i\) (Borchers and Efford 2008). The sums are over all individuals ever seen. Session-specific abundances are inferred by distributing \(N\) or \(D\) over sessions according to the entry probabilities \(b\). Alternatively (<code>HTbysession = TRUE</code>) the H-T estimate may be based on the number detected in each session and the corresponding session-specific estimates of \(p\) or \(a\).</li>
<li>Any of the recruitment parameters in Table 2 or Table 4 may be computed from any other model of the same class (non-spatial or spatial)[<sup>footnote12].</sup></li>
</ol>

<p>[<sup>footnote12]:</sup> However, the effect of a constraint (e.g., parameter constant over sessions) will vary depending on the parameter to which it is applied. </p>

<p>Both goals are served by the <code>derived</code> method for <code>openCR</code> objects. Among other outputs, this generates a summary table with point estimates of all relevant parameters. We demonstrate this with a new dipper model, fitted using conditional likelihood:</p>

<pre><code class="r">dipperCL &lt;- openCR.fit(dipperCH, type = &#39;JSSAlCL&#39;, 
            model = list(lambda~t, phi~t))
# only these parameters are in the model and estimated directly,
names(predict(dipperCL))
</code></pre>

<pre><code>## [1] &quot;p&quot;      &quot;phi&quot;    &quot;lambda&quot;
</code></pre>

<pre><code class="r"># but we can derive b, f, gamma and N, as well as the super-population N
d &lt;- derived(dipperCL)
print(d, digits = 3, legend = TRUE)
</code></pre>

<pre><code>## Total number observed 294 
## Parameters in model p, phi, lambda 
## Superpopulation size 310.6 
## Session-specific counts and estimates:
## 
##  session t  n  R  m  r z time     p   phi lambda      b     f gamma kappa     N
##        1 1 22 22  0 13 0    0 0.902 0.626  2.792 0.0785 2.166    NA    NA  24.4
##        2 2 60 60 11 25 2    1 0.902 0.454  1.265 0.1701 0.811 0.224  2.23  68.1
##        3 3 78 78 26 36 1    2 0.902 0.478  1.026 0.1778 0.548 0.359  2.36  86.2
##        4 4 80 80 35 48 2    3 0.902 0.624  1.104 0.1519 0.480 0.466  2.05  88.4
##        5 5 88 88 47 51 3    4 0.902 0.608  1.103 0.1365 0.495 0.566  1.86  97.6
##        6 6 98 98 52 52 2    5 0.902 0.583  0.958 0.1554 0.375 0.551  2.09 107.6
##        7 7 93 93 54  0 0    6 0.902    NA     NA 0.1298    NA 0.609  1.77 103.1
## 
##  Field   Definition                                     
##  ------- -----------------------------------------      
##  session primary session                                
##  t       primary session                                
##  n       number observed                                
##  R       number released                                
##  m       number already marked                          
##  r       number recaptured in later session             
##  z       number known alive but not caught              
##  time    accumulated time since start                   
##  p       detection probability per secondary session    
##  phi     apparent survival per unit time                
##  lambda  population growth rate per unit time           
##  b       entry probabilities                            
##  f       per capita recruitment per unit time           
##  gamma   seniority (cf reverse-time phi)                
##  kappa   recruitment parameter of Link and Barker (2005)
##  N       population size
</code></pre>

<p>The <code>print</code> method for objects from <code>derived</code> provides some control over formatting, as shown. Use the Dscale argument to change area units (spatial models only).</p>

<p><code>derived</code> does not yet provide delta-method SE or confidence intervals for derived parameters. A reliable workaround for abundance paramaters (N, D)[<sup>footnote13]</sup> is to (i) infer the point estimates with <code>derived</code>[<sup>footnote14],</sup> (ii) assemble a start vector on the link scale(s) for an equivalent full-likelihood <code>openCR.fit</code> model that includes the derived abundances, and (iii) run <code>openCR.fit</code> with <code>method = &quot;none&quot;</code> to compute the hessian at the MLE, and hence the full variance-covariance matrix.</p>

<p>[<sup>footnote13]:</sup> This may sometimes be feasible for derived recruitment parameters, but given the doubts introduced by differing constraints it is better just to refit the model.</p>

<p>[<sup>footnote14]:</sup> These are also the MLE when distribution = &ldquo;poisson&rdquo; (e.g., Schofield and Barker 2016).</p>

<h1>Simulating open-population data</h1>

<p>The <strong>secr</strong> functions <code>sim.popn</code> and <code>sim.capthist</code> provide the means to generate spatial open-population data with known survival probability, population trend \(\lambda\) and detection parameters. Open population data are generated by setting nsessions &gt; 1 in <code>sim.popn</code> and specifying a value for \(\lambda\). Turnover settings are controlled by components of the &#39;details&#39; argument of <code>sim.popn</code>. The <strong>secr</strong> help page ?turnover should be consulted. <code>sim.capthist</code> should be called with renumber = FALSE (otherwise individual capture histories cannot be matched across primary sessions). </p>

<p>Use the <strong>openCR</strong> function <code>sim.nonspatial</code> to generate non-spatial open-population data. <strong>openCR</strong> also provides these finctions to streamline simulation and speed it up by using multiple cores &ndash;</p>

<table><thead>
<tr>
<th>Function</th>
<th>Purpose</th>
</tr>
</thead><tbody>
<tr>
<td><code>runsim.nonspatial</code></td>
<td>Generate data with <code>sim.nonspatial</code> and fit models using <code>openCR.fit</code></td>
</tr>
<tr>
<td><code>runsim.spatial</code></td>
<td>Generate data with <code>sim.popn</code> and <code>sim.capthist</code>, and fit models using <code>openCR.fit</code></td>
</tr>
<tr>
<td><code>sumsims</code></td>
<td>Summarise list output from <code>runsim.nonspatial</code> or <code>runsim.spatial</code></td>
</tr>
</tbody></table>

<p><code>runsim.nonspatial</code> and <code>runsim.spatial</code> are essentially wrappers; the user must provide appropriate argument values for each of the nested functions. See openCR-simulations.pdf for example code.</p>

<h1>Troubleshooting</h1>

<h2>Nonidentifiability</h2>

<p>It is common for some session-specific parameters of open capture&ndash;recapture models to be nonidentifiable, either for structural reasons or because the particular dataset is uninformative (e.g., Gimenez et al. 2004). </p>

<p>The main diagnostic is the rank of the Hessian matrix. If the rank is less than the number of parameters then the model is not fully identifiable and the estimates of some parameters will be confounded or unreliable. Matrix rank is determined numerically by counting non-zero eigenvalues. Computed eigenvalues of non-identifiable parameters may appear as small positive numbers, so it is necessary to apply an arbitrary numerical threshold.</p>

<p>Exactly which parameter estimates are unreliable can usually be discerned from computed variances (SE and confidence intervals). Data cloning (Lele et al. 2010) is also helpful; function <code>cloned.fit</code> implements the method for nonspatial models.</p>

<p>Session-specific turnover parameters may become nonidentifiable if home ranges are allowed to move freely between primary sessions (<code>movementmodel = &#39;uncorrelated&#39;</code>). Intuitively, this is because radical changes in individual detection probability (due to proximity to detectors) cannot be separated from mortality and recruitment.</p>

<h2>Failure of numerical maximization</h2>

<p>Bad estimates (zero, very large, close to starting values or zero variance) may merely indicate a problem with the maximization algorithm rather than nonidentifiability.</p>

<h3>Starting values</h3>

<p>Numerical maximization of the likelihood requires appropriate starting values for the parameters. If starting values are poor then initial evaluations of the likelihood may return an infinite value, or otherwise provide inadequate direction for the numerical algorithm. </p>

<p><code>openCR.fit</code> provides a mechanism for recycling earlier estimates as starting values: simply provide the name of a previously fitted model as the start argument. Parameters shared between the models will be set to the old estimates, while unmatched parameters will be set to defaults. A list of two previous models may be provided; values from the first take precedence.</p>

<h3>Boundary estimates</h3>

<p>Variance estimation based on the Hessian matrix fails if the estimate lies on a boundary of the parameter space. Computed SE are then extreme, and confidence limits are implausible. This commonly happens when apparent survival (phi) approaches 1.0. Boundary estimates are more benign than other reasons for failure (the estimates themselves may be reliable). Alternative methods for variance estimation in this case have not been implemented.</p>

<p>Using the &ldquo;sin&rdquo; link for parameters bounded by 0 and 1 (the probability parameters p and phi) can be helpful. </p>

<h3>Alternative algorithms</h3>

<p>The default method for maximizing the likelihood function is Newton-Raphson as implemented in the R function <code>nlm</code>. This relies on numerical gradient estimates, which can cause trouble. Avoid gradient estimation entirely by using the somewhat slower &#39;Nelder-Mead&#39; method of function <code>optim</code> e.g., </p>

<pre><code class="r">fitnr &lt;- openCR.fit(ovenCH, type = &#39;JSSAlCL&#39;, model = list(phi ~ t, lambda~t))
fitnm &lt;- openCR.fit(ovenCH, type = &#39;JSSAlCL&#39;, model = list(phi ~ t, lambda~t),
                    method = &quot;Nelder-Mead&quot;, details = list(control = list(maxit = 5000)))
</code></pre>

<p>The default maximum number of likelihood evaluations for the Nelder-Mead algorithm (500) is often too small and results in a &ldquo;probable maximization error&rdquo; warning. Here we increase it to 2000 by setting the details argument &ldquo;control&rdquo; that is passed to <code>optim</code>.</p>

<p>Somewhat alarmingly, the NM algorithm settles on a lower log likelihood and different estimates:</p>

<pre><code class="r">AIC(fitnm,fitnr)
</code></pre>

<pre><code>##                    model npar rank logLik  AIC AICc  dAIC  AICwt
## fitnr p~1 phi~t lambda~t    9    9 -656.7 1331 1334 0.000 0.9898
## fitnm p~1 phi~t lambda~t    9    9 -661.3 1341 1344 9.154 0.0102
</code></pre>

<p>We can fix that by feeding Nelder-Mead the starting values from another model: </p>

<pre><code class="r">fitnm &lt;- openCR.fit(ovenCH, type = &#39;JSSAlCL&#39;, model = list(phi ~ t, lambda~t),
                    method = &quot;Nelder-Mead&quot;, details = list(control = list(maxit = 2000)),
                    start = fitnr)
AIC(fitnm,fitnr)
</code></pre>

<pre><code>##                    model npar rank logLik  AIC AICc dAIC AICwt
## fitnm p~1 phi~t lambda~t    9    9 -656.7 1331 1334    0   0.5
## fitnr p~1 phi~t lambda~t    9    9 -656.7 1331 1334    0   0.5
</code></pre>

<p>In the longer term, better maximizers are needed.</p>

<h2>Speed</h2>

<p>Spatial models are slow to fit. Consider these options</p>

<ul>
<li>Use no more mask points than necessary. Typically about 1000 will do (may not apply for kernel movement models).</li>
<li>Data with many occasions (secondary sessions) should be collapsed.</li>
<li>If you are interested in several models, fit them all at once with <code>par.openCR.fit</code> and ncores &gt; 1. This can save a lot of time.</li>
<li>Don&#39;t assume that increasing the number of cores will necessarily speed up computations; additional cores impose overheads in cluster setup and communication.</li>
<li>Use the conditional likelihood (CL) models: estimates of phi and lambda are often all you need, and <code>derive</code> can give estimates of abundance (superN, N, superD, and D) from CL models, as well as alternative measures of recruitment.</li>
<li>Avoid individual covariates with many levels. This applies especially to continuous individual covariates: normally these should be discretized (coded as a few ordered categories, but <em>not</em> converted to factor).</li>
<li>First fit the most simple model and add complexity, using a simpler related model for &#39;start&#39;.</li>
<li>&#39;secr&#39; data with detector type &#39;multi&#39; fit much faster than &#39;proximity&#39; data; use this option if it makes sense (and even maybe when it doesn&#39;t).</li>
<li>For problems with many parameters, &#39;cyclic fixing&#39; may be useful (Schwarz and Arnason 1996; Pledger et al. 2003).</li>
</ul>

<p><strong>openCR</strong> \(\ge\) 1.2 is generally faster than <strong>openCR</strong> 1.1 because it automatically uses multiple threads to run some calculations in parallel. The speed difference can be impressive - around 4x. Multithreading uses <a href="https://rcppcore.github.io/RcppParallel/">RcppParallel</a>. A couple of tuning parameters are available. The number of threads is set with ncores argument in <code>openCR.fit</code>. By default, <strong>openCR</strong> uses one less than the number of (virtual) cores available (i.e. 7 on a quad-core desktop with hyperthreading). The grain size&#39; (see <a href="https://rcppcore.github.io/RcppParallel/">RcppParallel</a> may be varied with details$grain, but seems to have little effect. </p>

<h1>Extras</h1>

<h2>Sampling variance warning {#warning}</h2>

<p>Full models (not CL or Pradel) include superpopulation size \(N\) as a variable. The default in <strong>openCR</strong> for both non-spatial and spatial models is to treat \(N\) as a Poisson variable, from which it follows that the number of individuals detected at least once (\(n\)) is also Poisson. This is also the default in <strong>secr</strong>. However, estimates from POPAN models in MARK treat \(N\) as fixed and \(n\) as binomial. The assumption of fixed \(N\) leads to narrower confidence intervals and estimates of detection and turnover parameters that differ slightly from conditional likelihood models (see e.g. Schofield and Barker 2016). To obtain JSSA estimates from <strong>openCR</strong> that match those from MARK it is necessary to set <code>distribution = &quot;binomial&quot;</code>.</p>

<h2>Example datasets</h2>

<p>Several examples of analyses with <strong>openCR</strong> are given in the associated vignette <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a>. These use data already formatted as <strong>secr</strong> capthist objects in R; the objects are provided in one or other package. All are available immediately <strong>openCR</strong> is loaded with <code>library</code>. Each has its own help page.</p>

<p>Table 6. Data objects in <strong>openCR</strong>. &#39;RD&#39; indicates robust design with multiple secondary sessions. See <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a> for references.</p>

<table><thead>
<tr>
<th align="left">Data object</th>
<th align="left">Spatial</th>
<th align="left">RD</th>
<th align="left">Species etc.</th>
<th align="left">Source</th>
</tr>
</thead><tbody>
<tr>
<td align="left">microtusCH etc.</td>
<td align="left">No</td>
<td align="left">Yes*</td>
<td align="left">Meadow vole <em>Microtus pennsylvanicus</em> USA</td>
<td align="left">Nichols et al. (1984), Williams et al. (2002)</td>
</tr>
<tr>
<td align="left">FebpossumCH</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">Brushtail possum <em>Trichosurus vulpecula</em> New Zealand</td>
<td align="left">M. Efford unpubl.</td>
</tr>
<tr>
<td align="left">dipperCH</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">European dipper <em>Cinclus cinclus</em> France</td>
<td align="left">Lebreton et al. (1992), MARK</td>
</tr>
<tr>
<td align="left">gonodontisCH</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Moth <em>Gonodontis bidentata</em> England</td>
<td align="left">Bishop et al. (1978), Crosbie (1979)</td>
</tr>
<tr>
<td align="left">fieldvoleCH</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Field vole <em>Microtus agrestis</em> Norway</td>
<td align="left">Ergon and Lambin (2013)</td>
</tr>
</tbody></table>

<p>Table 7. Multi-session data objects in <strong>secr</strong>. </p>

<table><thead>
<tr>
<th align="left">Data object</th>
<th align="left">Spatial</th>
<th align="left">RD</th>
<th align="left">Species etc.</th>
<th align="left">Source</th>
</tr>
</thead><tbody>
<tr>
<td align="left">OVpossumCH</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Brushtail possum <em>Trichosurus vulpecula</em> New Zealand</td>
<td align="left">M. Efford unpubl.</td>
</tr>
<tr>
<td align="left">ovenCHp</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Ovenbird <em>Seiurus aurocapilla</em> USA</td>
<td align="left">D. Dawson and M. Efford unpubl.</td>
</tr>
</tbody></table>

<h2>Testing assumptions</h2>

<p>This is generally an undeveloped field for spatially explicit capture&ndash;recapture models. Demonstrating that assumptions were not satisfied may also be of no consequence: we would usually ignore such a finding if the estimator is reasonably robust. </p>

<p>For Cormack-Jolly-Seber (nonspatial) models there is an established suite of tests following Burnham et al. (1987). The tests have been implemented in the U-CARE software of Choquet et al. (2009), recently translated into R by Gimenez et al (2018) as package <strong>R2ucare</strong>. Program RELEASE (Burnham et al. 1987) also implements the core CJS tests and is available through MARK.</p>

<p>The <strong>openCR</strong> function <code>ucare.cjs</code> is a wrapper for relevant functions in <strong>R2ucare</strong>, which should be installed. We briefly demonstrate it here for the dipper data of Marzolin (1988).</p>

<pre><code class="r">if (requireNamespace(&quot;R2ucare&quot;))
    ucare.cjs(dipperCH, verbose = FALSE, by = &#39;sex&#39;)
</code></pre>

<pre><code>## Loading required namespace: R2ucare
</code></pre>

<pre><code>## $Male
## $Male$components
##          stat df p_val sign_test
## test3sr 6.778  5 0.238    -1.530
## test3sm 0.000  2 1.000        NA
## test2ct 4.284  2 0.117    -1.035
## test2cl 0.000  0 1.000        NA
## 
## $Male$overall_CJS
##                          chi2 degree_of_freedom p_value
## Gof test for CJS model: 11.06                 9   0.271
## 
## 
## $Female
## $Female$components
##          stat df p_val sign_test
## test3sr 4.985  5 0.418     1.428
## test3sm 2.041  3 0.564        NA
## test2ct 3.250  4 0.517    -0.901
## test2cl 0.000  0 1.000        NA
## 
## $Female$overall_CJS
##                          chi2 degree_of_freedom p_value
## Gof test for CJS model: 10.28                12   0.592
</code></pre>

<p>This invocation of <code>ucare.cjs</code> calls the <strong>R2ucare</strong> functions <code>test3sr</code>, <code>test3sm</code>, <code>test2ct</code>, <code>test2cl</code> and <code>overall_CJS</code> for each sex and provides a condensed report. For interpretation see the original papers, the <strong>R2ucare</strong> <a href="https://cran.r-project.org/package=R2ucare/vignettes/vignette_R2ucare.html">vignette</a>, and Chapter 5 of the MARK book (Cooch and White 2017).  Lebreton et al. (1992: 86) indicate only Test 3SR is meaningful for these data (see also <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a>).</p>

<h2>Limitations of <strong>openCR</strong> {#limitations}</h2>

<p><strong>openCR</strong> does not do</p>

<ol>
<li>Continuous random effects (consider finite mixtures as an alternative)</li>
<li>Parameter counting to adjust AIC</li>
<li>Overdispersion adjustment (chat, QAIC) or goodness-of-fit tests, except for <code>ucare.cjs</code> (above).</li>
<li>MCMC</li>
<li>Bootstrap confidence intervals</li>
<li>Temporary emigration parameterizations of non-spatial robust-design models</li>
<li>Age-specific survival curves (Weibull etc.)</li>
<li>Mark-resight</li>
<li>SE for derived parameters and estimates with mlogit link (to be fixed)</li>
</ol>

<p>Parameter counting and overdispersion adjustment are probably the most critical omissions. See Cooch and White (2017) for detailed coverage in the context of MARK.</p>

<h2>Differences from <strong>secr</strong>  {#differences}</h2>

<p>Defaults for some arguments differ between <code>openCR.fit</code> and <code>secr.fit</code>. For <code>openCR.fit</code> &ndash;</p>

<ol>
<li><code>trace = FALSE</code></li>
<li>By default the reported log likelihood and AIC do  not include the multinomial constant (<code>details$multinom = FALSE</code>)</li>
<li>The default criterion for AIC.openCR is &#39;AIC&#39;, not &#39;AICc&#39; as in <strong>secr</strong>.</li>
</ol>

<p><code>distribution</code> has been elevated to a full argument rather than merely a component of <code>details</code>. This argument describes the distribution of the  number of individuals detected (default distribution = &ldquo;poisson&rdquo;) (see <a href="#warning">here</a>).</p>

<p>When <code>details$LLonly = TRUE</code>,  <code>openCR.fit</code> returns a vector with the log likelihood in position 1, followed by the named starting values of the coefficients (beta parameters) (<code>secr.fit</code> returns only the log likelihood).</p>

<p>In <strong>secr</strong> the argument <code>CL</code> is used in <code>secr.fit</code> to switch between full- and conditional-likelihood models. In <strong>openCR</strong> conditional-likelihood models are given a separate <code>type</code> with the suffix CL.</p>

<p>The predictor &#39;t&#39; is used in <strong>secr</strong> models to indicate a factor with one level for each <em>secondary</em> session. In <strong>openCR</strong> it is a synonym for &#39;session&#39;, i.e. a factor with one level for each <em>primary</em> session. This is consistent with the use of &#39;t&#39; in Lebreton et al. (1992) and makes for more compact model specification. In the unlikely event that you want to code a model with one level for each secondary session in <strong>openCR</strong>, use the &#39;timecov&#39; argument.</p>

<p>Parts of <strong>openCR</strong> are coded in C++, via the R package <strong>Rcpp</strong>, whereas <strong>secr</strong> uses C. The <strong>Rcpp</strong> interface requires less copying of data, and enables the use of multiple threads via <strong>RcppParallel</strong>. <strong>openCR</strong> also duplicates some C++ functions in native R code, which is useful for debugging. Select the R version by setting <code>details = list(R = TRUE)</code> in <code>openCR.fit</code>. This currently works for most models except those with detector type &#39;multi&#39;.</p>

<p>These features of <strong>secr</strong> are not available in <strong>openCR</strong></p>

<ol>
<li>Hybrid mixture models (hcov in <strong>secr</strong>)</li>
<li>Groups (use CL and individual covariates, or see <strong>marked</strong>)</li>
<li>Regression splines from <strong>mgcv</strong></li>
<li>Model averaging</li>
<li>Density surfaces and other spatial density models</li>
<li>Post-hoc probability density of activity centres (fxi in <strong>secr</strong>)</li>
<li>Non-point detectors (polygon, polygonX etc. in <strong>secr</strong>)</li>
<li>&#39;collate&#39; function (<code>make.table</code> may do the job)</li>
<li>Variable effort for <em>nonspatial</em> models (cf Efford, Borchers and Mowat 2013) (The &#39;usage&#39; attribute of traps objects is applied in spatial <strong>openCR</strong> models).</li>
<li>Negative binomial counts (binomN&lt;0)</li>
</ol>

<h2>Relationship to other software</h2>

<p>The non-spatial capability of <strong>openCR</strong> largely duplicates MARK and RMark.
Several of the nonspatial model types have exact matches in MARK (Table 8).</p>

<p>Table 8. Relationship of non-spatial <strong>openCR</strong> models to MARK model types</p>

<table><thead>
<tr>
<th align="left"><strong>openCR</strong> type</th>
<th>MARK model</th>
<th>Reference</th>
</tr>
</thead><tbody>
<tr>
<td align="left">CJS</td>
<td>CJS</td>
<td>Seber (1982)</td>
</tr>
<tr>
<td align="left">JSSAb</td>
<td>POPAN</td>
<td>Schwarz and Arnason (1996)</td>
</tr>
<tr>
<td align="left">JSSAfCL</td>
<td>LinkBarker</td>
<td>Link and Barker (2005)</td>
</tr>
<tr>
<td align="left">Pradel</td>
<td>Pradlambda</td>
<td>Pradel (1996)</td>
</tr>
<tr>
<td align="left">Pradelg</td>
<td>Pradsen</td>
<td>Pradel (1996)</td>
</tr>
</tbody></table>

<p>The R package <strong>marked</strong> (Laake, Johnson and Conn 2013) also overlaps substantially with the non-spatial features of <strong>openCR</strong>. Its interface echoes <strong>RMark</strong> just as <strong>openCR</strong> echoes <strong>secr</strong>. <strong>marked</strong> has some fancy features for individual covariates and random effects, and promises fast processing of large datasets. <strong>marked</strong> 1.1.13 includes full-likelihood JSSA (POPAN) models parameterized in terms of entry probabilities (type JSSAb)[<sup>footnote15],</sup> but not the other JSSA options in Table 2.</p>

<p>[<sup>footnote15]:</sup> dipper example in <a href="https://www.otago.ac.nz/density/pdfs/openCR-examples.pdf">openCR-examples.pdf</a>.</p>

<h1>References</h1>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<strong>64</strong>, 377&ndash;385.</p>

<p>Burnham, K. P., Anderson, D. R., White, G. C., Brownie, C. and Pollock, K. H. (1987) 
<em>Design and Analysis Methods for Fish Survival Experiments Based on Release-Recapture.</em> 
American Fisheries Society Monograph 5. Bethesda, Maryland, USA.</p>

<p>Chandler, R. B. and Clark, J. D. (2014) Spatially explicit integrated population models. 
<em>Methods in Ecology and Evolution</em> <strong>5</strong>, 1351&ndash;1360.</p>

<p>Choquet, R., Lebreton, J.-D., Gimenez, O., Reboulet, A.-M. and Pradel, R. (2009) 
U-CARE: Utilities for performing goodness of fit tests and manipulating CApture-REcapture data.
 <em>Ecography</em> <strong>32</strong>, 1071&ndash;1074.</p>

<p>Nathan , R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) 
Dispersal kernels: a review. In: J Clobert et al. <em>Dispersal Ecology and Evolution</em>. 
Oxford University Press. Pp 187&ndash;210.</p>

<p>Cooch, E. and White, G. (eds) (2017) <em>Program MARK: A Gentle
Introduction</em>. 17th edition. Available online at
<a href="http://www.phidot.org/software/mark/docs/book/">http://www.phidot.org/software/mark/docs/book/</a>.</p>

<p>Crosbie, S. F. and Manly, B. F. J. (1985) Parsimonious modelling of capture&ndash;mark&ndash;recapture studies.
<em>Biometrics</em> <strong>41</strong>, 385&ndash;398.</p>

<p>Efford, M. G. (2004) Density estimation in live-trapping
studies. <em>Oikos</em> <strong>106</strong>, 598&ndash;610.</p>

<p>Efford, M. G. (2019). secr: Spatially explicit capture&ndash;recapture models. R package version
  3.2.1. <a href="https://CRAN.R-project.org/package=secr/">https://CRAN.R-project.org/package=secr/</a></p>

<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density
  estimation by spatially explicit capture&ndash;recapture:
  likelihood-based methods. In: D. L. Thomson, E. G. Cooch,
  M. J. Conroy (eds) <em>Modeling Demographic Processes in Marked
  Populations</em>. Springer. Pp 255&ndash;269.</p>

<p>Efford, M. G., Borchers D. L. and Mowat, G. (2013) Varying effort in
capture&ndash;recapture studies. <em>Methods in Ecology and Evolution</em> <strong>4</strong>,
629&ndash;636.</p>

<p>Efford, M. G. and Fewster, R. M. (2013) Estimating population size by
spatially explicit capture&ndash;recapture. <em>Oikos</em> <strong>122</strong>, 918&ndash;928.</p>

<p>Efford, M. G. and Schofield, M. R. (2020) A spatial open-population capture&ndash;recapture model.
  <em>Biometrics</em> <strong>76</strong>, 392&ndash;402.</p>

<p>Ergon, T. and Gardner, B. (2014) Separating mortality and emigration: modelling space
use, dispersal and survival with robust-design spatial capture&ndash;recapture data. 
<em>Methods in Ecology and Evolution</em> <strong>5</strong>, 1327&ndash;1336.</p>

<p>Fletcher, D. J. (2012) Estimating overdispersion when fitting a generalized linear model to sparse data. <em>Biometrika</em> <strong>99</strong>, 230&ndash;237.</p>

<p>Gardner, B. J., Reppucci, J., Lucherini, M. and Royle, J. A. (2010) Spatially-explicit 
inference for open populations: estimating demographic parameters from camera-trap studies. 
<em>Ecology</em> <strong>91</strong>, 3376&ndash;3383.</p>

<p>Gimenez, O., Viallefont, A., Catchpole, E. A., Choquet, R. and Morgan,
  B. J. T. (2004) Methods for investigating parameter
  redundancy. <em>Animal Biodiversity and Conservation</em> <strong>27</strong>,
  561&ndash;572.</p>

<p>Gimenez, O., Lebreton, J.-D., Choquet, R. and Pradel, R. (2017) R2ucare: Goodness-of-Fit Tests
  for Capture-Recapture Models. R package version 1.0.0. <a href="https://CRAN.R-project.org/package=R2ucare/">https://CRAN.R-project.org/package=R2ucare/</a></p>

<p>Gimenez, O., Lebreton, J.-D., Choquet, R. and Pradel, R. (2018) R2ucare: An R package to perform 
goodness-of-fit tests for capture&ndash;recapture models. <em>Methods in Ecology and Evolution</em> <strong>9</strong>, 1749&ndash;1754.</p>

<p>Glennie, R., Borchers, D. L., Murchie, M. Harmsen, B. J. and Foster, R. J. (2019) Open population maximum likelihood spatial capture&ndash;recapture. <em>Biometrics</em> <strong>75</strong>, 1345&ndash;1355.</p>

<p>Hines, J. E., Kendall, W. L. and Nichols, J. D. (2003) On the use of the robust design with transient capture&ndash;recapture models. <em>The Auk</em> <strong>120</strong>, 1151&ndash;1158.</p>

<p>Huggins, R. M. (1989) On the statistical analysis of capture
  experiments. <em>Biometrika</em> <strong>76</strong>, 133&ndash;140.</p>

<p>Laake, J.L., Johnson, D. S. and Conn, P.B. (2013) marked: An R package for maximum-likelihood and MCMC
  analysis of capture-recapture data. <em>Methods in Ecology and Evolution</em> <strong>4</strong>, 885&ndash;890.</p>

<p>Laake, J. and Rexstad E. (2014) Appendix C. RMark - an alternative
    approach to building linear models in MARK. In: Cooch, E. and
    White, G. (eds) <em>Program MARK: A Gentle Introduction</em>. 13th
    edition. <a href="http://www.phidot.org/software/mark/docs/book/">http://www.phidot.org/software/mark/docs/book/</a>.</p>

<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., and Anderson,
D. R. (1992) Modeling survival and testing biological hypotheses using
marked animals: a unified approach with case studies. 
<em>Ecological Monographs</em> <strong>62</strong>, 67&ndash;118.</p>

<p>Lele, S.R., Nadeem, K. and Schmuland, B. (2010) Estimability and likelihood 
inference for generalized linear mixed models using data cloning. 
<em>Journal of the American Statistical Association</em> <strong>105</strong>, 1617&ndash;1625.</p>

<p>Link, W. A. and Barker, R. J. (2005) Modeling association among demographic 
parameters in analysis of open-population capture&ndash;recapture data.
<em>Biometrics</em> <strong>61</strong>, 46&ndash;54.</p>

<p>Link, W. A. and Barker, R. J. (2010) <em>Bayesian Inference with Ecological Applications</em>. 
Academic Press, Amsterdam.</p>

<p>Marzolin, G. (1988) Polygynie du CineIe plongeur (<em>Cinclus cinclus</em>) dans 
les cotes de Lorraine. L&#39;Oiseau et la Revue Francaise d&#39;Ornithologie 58:277-286.</p>

<p>Nathan , R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) 
Dispersal kernels: a review. In: J Clobert et al. <em>Dispersal Ecology and Evolution</em>. 
Oxford University Press. Pp 187&ndash;210.</p>

<p>Nichols, J. D., Pollock, K. H. and Hines, J. E (1984) The use of a robust capture&ndash;recapture 
design in small mammal population studies: a field example with <em>Microtus pennsylvanicus</em>. 
<em>Acta Theriologica</em> <strong>29</strong>, 357&ndash;365.</p>

<p>Nichols, J. D. (2016) And the first one now will later be last:
time-reversal in Cormack&ndash;Jolly&ndash;Seber models. <em>Statistical Science</em> <strong>31</strong>, 175&ndash;190.</p>

<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2003) Open
  capture&ndash;recapture models with heterogeneity: I. Cormack&ndash;Jolly&ndash;Seber
  model. <em>Biometrics</em> <strong>59</strong>, 786&ndash;794.</p>

<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2010) Open
  capture&ndash;recapture models with heterogeneity: II. Jolly&ndash;Seber
  model. <em>Biometrics</em> <strong>66</strong>, 883&ndash;890.</p>

<p>Pollock, K. H. (1982) A capture&ndash;recapture design robust to unequal probability of capture.
<em>Journal of Wildlife Management</em> <strong>46</strong>, 752&ndash;757.</p>

<p>Pradel, R. (1996) Utilization of capture-mark-recapture for the study
  of recruitment and population growth rate. <em>Biometrics</em> <strong>52</strong>,
  703&ndash;709.</p>

<p>Pradel, R., Hines, J. E., Lebreton, J.-D. and Nichols, J. D. (1997) Capture&ndash;recapture survival models taking account of transients. <em>Biometrics</em> <strong>53</strong>, 60&ndash;72.</p>

<p>Royle, J. A., Chandler, R. B., Sollmann, R. and Gardner, B. (2014) <em>Spatial capture&ndash;recapture</em>. Academic Press.</p>

<p>Schwarz, C. J. (2001) The Jolly-Seber model: more than just abundance. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> <strong>6</strong>, 195&ndash;205.</p>

<p>Schwarz, C. J. and Arnason, A. N. (1996) A general methodology for the
  analysis of capture-recapture experiments in open
  populations. <em>Biometrics</em> <strong>52</strong>, 860&ndash;873.</p>

<p>Schofield, M. and Barker, R. (2016) 50-year-old curiosities: ancillarity and inference in capture&ndash;recapture models. <em>Statistical Science</em> <strong>31</strong>, 161&ndash;174.</p>

<p>Seber, G. A. F. (1982) <em>The estimation of animal abundance and related parameters</em>. 2nd edition. Griffin.</p>

<p>White, G. C. and Burnham, K. P. (1999) Program MARK: survival estimation from populations of marked animals. <em>Bird Study</em> <strong>46</strong>, Supplement S120&ndash;S139.</p>

<p>Whittington, J. and Sawaya, M. A. (2015) A comparison of grizzly bear demographic parameters
estimated from non-spatial and spatial open population capture&ndash;recapture models. 
<em>PLoS ONE</em> <strong>10</strong>, e0134446. <a href="https://doi.org/10.1371/journal.pone.0134446">https://doi.org/10.1371/journal.pone.0134446</a></p>

<p>Williams, B. K., Nichols, J. D. and Conroy, M. J. (2002) <em>Analysis and management of animal populations</em>. 
Academic Press, San Diego.</p>

<!-- # Appendix. Relationships between parameterisations of recruitment {#appendix1} -->

<!-- Limits on the range of -->

<!-- |   | $f$            |  $\gamma$ |  $\lambda$   | $\beta$ |  $B$ | $N_j$ | -->

<!-- |------|-----------------|--------------------|-----------|------------|-----------|---------------| -->

<!-- |$f_i$          | --- |  $\phi_i (1/\gamma_{i+1} - 1)$ | $\lambda_i - \phi_i$ | $\beta_i / d_i$ | -->

<!-- |$\gamma_{i+1}$ | $\phi_i / (\phi_i + f_i)$ | --- |  $\phi_i / \lambda_i$     | | | -->

<!-- |$\lambda_i$    | $\phi_i + f_i$ | $\phi_i / \gamma_{i+1}$ | --- | | | | -->

<!-- |$\beta_i$      | $f_i d_i / \sum f_i d_i$ | $\beta_0 f_i \prod_{j=1}^{i-1} (\phi_j + f_j)$ |        | --- | | $(N_{i+1} - N_i) / N$ | -->

<!-- |$D_i$          |      |                         |        |     | --- |  || -->

<!-- |$B_i$          |  $f_iN_i$    |                         |        |     | --- | $\beta_i N$ || -->

<!-- |$d_{i+1}$      | $\beta_0 \prod_{j=1}^i (\phi_j + f_j)$ |          |        | | | | -->

<!-- $$ -->

<!-- b_0 = 1 -->

<!-- b_i = zzz -->

<!-- \beta_i = b_i / \sum b_i, \;\;\; i = 0..J -->

<!-- $$ -->

<p>\pagebreak</p>

</body>

</html>
